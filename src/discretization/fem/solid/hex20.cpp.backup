/**
 * @file hex20.cpp
 * @brief Implementation of 20-node hexahedral element (serendipity)
 */

#include <nexussim/discretization/hex20.hpp>
#include <cmath>
#include <algorithm>

namespace nxs {
namespace fem {

// ============================================================================
// Shape Functions
// ============================================================================

KOKKOS_INLINE_FUNCTION
void Hex20Element::shape_functions(const Real xi[3], Real* N) const {
    const Real xi_val = xi[0];
    const Real eta = xi[1];
    const Real zeta = xi[2];

    // Serendipity shape functions for 20-node hexahedron

    // Corner nodes (0-7): quadratic terms
    // N_i = (1 + ξ_iξ)(1 + η_iη)(1 + ζ_iζ)(ξ_iξ + η_iη + ζ_iζ - 2)/8

    // Node 0: (-1,-1,-1)
    // TESTING: Changed -2 to +2 in corner node formulas
    N[0] = 0.125 * (1.0 - xi_val) * (1.0 - eta) * (1.0 - zeta) *
           (-xi_val - eta - zeta + 2.0);

    // Node 1: (+1,-1,-1)
    N[1] = 0.125 * (1.0 + xi_val) * (1.0 - eta) * (1.0 - zeta) *
           (xi_val - eta - zeta + 2.0);

    // Node 2: (+1,+1,-1)
    N[2] = 0.125 * (1.0 + xi_val) * (1.0 + eta) * (1.0 - zeta) *
           (xi_val + eta - zeta + 2.0);

    // Node 3: (-1,+1,-1)
    N[3] = 0.125 * (1.0 - xi_val) * (1.0 + eta) * (1.0 - zeta) *
           (-xi_val + eta - zeta + 2.0);

    // Node 4: (-1,-1,+1)
    N[4] = 0.125 * (1.0 - xi_val) * (1.0 - eta) * (1.0 + zeta) *
           (-xi_val - eta + zeta + 2.0);

    // Node 5: (+1,-1,+1)
    N[5] = 0.125 * (1.0 + xi_val) * (1.0 - eta) * (1.0 + zeta) *
           (xi_val - eta + zeta + 2.0);

    // Node 6: (+1,+1,+1)
    N[6] = 0.125 * (1.0 + xi_val) * (1.0 + eta) * (1.0 + zeta) *
           (xi_val + eta + zeta + 2.0);

    // Node 7: (-1,+1,+1)
    N[7] = 0.125 * (1.0 - xi_val) * (1.0 + eta) * (1.0 + zeta) *
           (-xi_val + eta + zeta + 2.0);

    // Mid-edge nodes (8-19): one coordinate at 0, quadratic in that direction
    // N_i = (1 - ξ²)(1 + η_iη)(1 + ζ_iζ)/4 for ξ=0 edges, etc.

    const Real xi2 = xi_val * xi_val;
    const Real eta2 = eta * eta;
    const Real zeta2 = zeta * zeta;

    // Bottom face edges (z=-1)
    N[8]  = 0.25 * (1.0 - xi2) * (1.0 - eta) * (1.0 - zeta);    // Edge 0-1 (ξ=0)
    N[9]  = 0.25 * (1.0 + xi_val) * (1.0 - eta2) * (1.0 - zeta); // Edge 1-2 (η=0)
    N[10] = 0.25 * (1.0 - xi2) * (1.0 + eta) * (1.0 - zeta);    // Edge 2-3 (ξ=0)
    N[11] = 0.25 * (1.0 - xi_val) * (1.0 - eta2) * (1.0 - zeta); // Edge 3-0 (η=0)

    // Vertical edges
    N[12] = 0.25 * (1.0 - xi_val) * (1.0 - eta) * (1.0 - zeta2);  // Edge 0-4 (ζ=0)
    N[13] = 0.25 * (1.0 + xi_val) * (1.0 - eta) * (1.0 - zeta2);  // Edge 1-5 (ζ=0)
    N[14] = 0.25 * (1.0 + xi_val) * (1.0 + eta) * (1.0 - zeta2);  // Edge 2-6 (ζ=0)
    N[15] = 0.25 * (1.0 - xi_val) * (1.0 + eta) * (1.0 - zeta2);  // Edge 3-7 (ζ=0)

    // Top face edges (z=+1)
    N[16] = 0.25 * (1.0 - xi2) * (1.0 - eta) * (1.0 + zeta);    // Edge 4-5 (ξ=0)
    N[17] = 0.25 * (1.0 + xi_val) * (1.0 - eta2) * (1.0 + zeta); // Edge 5-6 (η=0)
    N[18] = 0.25 * (1.0 - xi2) * (1.0 + eta) * (1.0 + zeta);    // Edge 6-7 (ξ=0)
    N[19] = 0.25 * (1.0 - xi_val) * (1.0 - eta2) * (1.0 + zeta); // Edge 7-4 (η=0)
}

KOKKOS_INLINE_FUNCTION
void Hex20Element::shape_derivatives(const Real xi[3], Real* dN) const {
    const Real xi_val = xi[0];
    const Real eta = xi[1];
    const Real zeta = xi[2];

    // Derivatives: dN[i*3 + j] = ∂N_i/∂ξ_j where j=0:ξ, j=1:η, j=2:ζ
    // NOTE: Computing with correct signs, will negate at end for testing

    // Corner nodes (0-7) - derivatives are complex for serendipity elements

    // Node 0: (-1,-1,-1) - ξ_i=-1, η_i=-1, ζ_i=-1
    // TESTING: Changed signs due to -2→+2 change in shape function
    dN[0*3 + 0] = -0.125 * (1.0 - eta) * (1.0 - zeta) * (-2.0*xi_val - eta - zeta + 1.0);
    dN[0*3 + 1] = -0.125 * (1.0 - xi_val) * (1.0 - zeta) * (-xi_val - 2.0*eta - zeta + 1.0);
    dN[0*3 + 2] = -0.125 * (1.0 - xi_val) * (1.0 - eta) * (-xi_val - eta - 2.0*zeta + 1.0);

    // Node 1: (+1,-1,-1) - ξ_i=+1, η_i=-1, ζ_i=-1
    dN[1*3 + 0] = 0.125 * (1.0 - eta) * (1.0 - zeta) * (2.0*xi_val - eta - zeta + 1.0);
    dN[1*3 + 1] = -0.125 * (1.0 + xi_val) * (1.0 - zeta) * (xi_val - 2.0*eta - zeta + 1.0);
    dN[1*3 + 2] = -0.125 * (1.0 + xi_val) * (1.0 - eta) * (xi_val - eta - 2.0*zeta + 1.0);

    // Node 2: (+1,+1,-1) - ξ_i=+1, η_i=+1, ζ_i=-1
    dN[2*3 + 0] = 0.125 * (1.0 + eta) * (1.0 - zeta) * (2.0*xi_val + eta - zeta + 1.0);
    dN[2*3 + 1] = 0.125 * (1.0 + xi_val) * (1.0 - zeta) * (xi_val + 2.0*eta - zeta + 1.0);
    dN[2*3 + 2] = -0.125 * (1.0 + xi_val) * (1.0 + eta) * (xi_val + eta - 2.0*zeta + 1.0);

    // Node 3: (-1,+1,-1) - ξ_i=-1, η_i=+1, ζ_i=-1
    dN[3*3 + 0] = -0.125 * (1.0 + eta) * (1.0 - zeta) * (-2.0*xi_val + eta - zeta + 1.0);
    dN[3*3 + 1] = 0.125 * (1.0 - xi_val) * (1.0 - zeta) * (-xi_val + 2.0*eta - zeta + 1.0);
    dN[3*3 + 2] = -0.125 * (1.0 - xi_val) * (1.0 + eta) * (-xi_val + eta - 2.0*zeta + 1.0);

    // Node 4: (-1,-1,+1) - ξ_i=-1, η_i=-1, ζ_i=+1
    dN[4*3 + 0] = -0.125 * (1.0 - eta) * (1.0 + zeta) * (-2.0*xi_val - eta + zeta + 1.0);
    dN[4*3 + 1] = -0.125 * (1.0 - xi_val) * (1.0 + zeta) * (-xi_val - 2.0*eta + zeta + 1.0);
    dN[4*3 + 2] = 0.125 * (1.0 - xi_val) * (1.0 - eta) * (-xi_val - eta + 2.0*zeta + 1.0);

    // Node 5: (+1,-1,+1) - ξ_i=+1, η_i=-1, ζ_i=+1
    dN[5*3 + 0] = 0.125 * (1.0 - eta) * (1.0 + zeta) * (2.0*xi_val - eta + zeta + 1.0);
    dN[5*3 + 1] = -0.125 * (1.0 + xi_val) * (1.0 + zeta) * (xi_val - 2.0*eta + zeta + 1.0);
    dN[5*3 + 2] = 0.125 * (1.0 + xi_val) * (1.0 - eta) * (xi_val - eta + 2.0*zeta + 1.0);

    // Node 6: (+1,+1,+1) - ξ_i=+1, η_i=+1, ζ_i=+1
    dN[6*3 + 0] = 0.125 * (1.0 + eta) * (1.0 + zeta) * (2.0*xi_val + eta + zeta + 1.0);
    dN[6*3 + 1] = 0.125 * (1.0 + xi_val) * (1.0 + zeta) * (xi_val + 2.0*eta + zeta + 1.0);
    dN[6*3 + 2] = 0.125 * (1.0 + xi_val) * (1.0 + eta) * (xi_val + eta + 2.0*zeta + 1.0);

    // Node 7: (-1,+1,+1) - ξ_i=-1, η_i=+1, ζ_i=+1
    dN[7*3 + 0] = -0.125 * (1.0 + eta) * (1.0 + zeta) * (-2.0*xi_val + eta + zeta + 1.0);
    dN[7*3 + 1] = 0.125 * (1.0 - xi_val) * (1.0 + zeta) * (-xi_val + 2.0*eta + zeta + 1.0);
    dN[7*3 + 2] = 0.125 * (1.0 - xi_val) * (1.0 + eta) * (-xi_val + eta + 2.0*zeta + 1.0);

    // Mid-edge nodes (8-19) - simpler derivatives

    // Bottom face edges (z=-1)
    dN[8*3 + 0] = -0.5 * xi_val * (1.0 - eta) * (1.0 - zeta);
    dN[8*3 + 1] = -0.25 * (1.0 - xi_val*xi_val) * (1.0 - zeta);
    dN[8*3 + 2] = -0.25 * (1.0 - xi_val*xi_val) * (1.0 - eta);

    dN[9*3 + 0] = 0.25 * (1.0 - eta*eta) * (1.0 - zeta);
    dN[9*3 + 1] = -0.5 * eta * (1.0 + xi_val) * (1.0 - zeta);
    dN[9*3 + 2] = -0.25 * (1.0 + xi_val) * (1.0 - eta*eta);

    dN[10*3 + 0] = -0.5 * xi_val * (1.0 + eta) * (1.0 - zeta);
    dN[10*3 + 1] = 0.25 * (1.0 - xi_val*xi_val) * (1.0 - zeta);
    dN[10*3 + 2] = -0.25 * (1.0 - xi_val*xi_val) * (1.0 + eta);

    dN[11*3 + 0] = -0.25 * (1.0 - eta*eta) * (1.0 - zeta);
    dN[11*3 + 1] = -0.5 * eta * (1.0 - xi_val) * (1.0 - zeta);
    dN[11*3 + 2] = -0.25 * (1.0 - xi_val) * (1.0 - eta*eta);

    // Vertical edges
    dN[12*3 + 0] = -0.25 * (1.0 - eta) * (1.0 - zeta*zeta);
    dN[12*3 + 1] = -0.25 * (1.0 - xi_val) * (1.0 - zeta*zeta);
    dN[12*3 + 2] = -0.5 * zeta * (1.0 - xi_val) * (1.0 - eta);

    dN[13*3 + 0] = 0.25 * (1.0 - eta) * (1.0 - zeta*zeta);
    dN[13*3 + 1] = -0.25 * (1.0 + xi_val) * (1.0 - zeta*zeta);
    dN[13*3 + 2] = -0.5 * zeta * (1.0 + xi_val) * (1.0 - eta);

    dN[14*3 + 0] = 0.25 * (1.0 + eta) * (1.0 - zeta*zeta);
    dN[14*3 + 1] = 0.25 * (1.0 + xi_val) * (1.0 - zeta*zeta);
    dN[14*3 + 2] = -0.5 * zeta * (1.0 + xi_val) * (1.0 + eta);

    dN[15*3 + 0] = -0.25 * (1.0 + eta) * (1.0 - zeta*zeta);
    dN[15*3 + 1] = 0.25 * (1.0 - xi_val) * (1.0 - zeta*zeta);
    dN[15*3 + 2] = -0.5 * zeta * (1.0 - xi_val) * (1.0 + eta);

    // Top face edges (z=+1)
    dN[16*3 + 0] = -0.5 * xi_val * (1.0 - eta) * (1.0 + zeta);
    dN[16*3 + 1] = -0.25 * (1.0 - xi_val*xi_val) * (1.0 + zeta);
    dN[16*3 + 2] = 0.25 * (1.0 - xi_val*xi_val) * (1.0 - eta);

    dN[17*3 + 0] = 0.25 * (1.0 - eta*eta) * (1.0 + zeta);
    dN[17*3 + 1] = -0.5 * eta * (1.0 + xi_val) * (1.0 + zeta);
    dN[17*3 + 2] = 0.25 * (1.0 + xi_val) * (1.0 - eta*eta);

    dN[18*3 + 0] = -0.5 * xi_val * (1.0 + eta) * (1.0 + zeta);
    dN[18*3 + 1] = 0.25 * (1.0 - xi_val*xi_val) * (1.0 + zeta);
    dN[18*3 + 2] = 0.25 * (1.0 - xi_val*xi_val) * (1.0 + eta);

    dN[19*3 + 0] = -0.25 * (1.0 - eta*eta) * (1.0 + zeta);
    dN[19*3 + 1] = -0.5 * eta * (1.0 - xi_val) * (1.0 + zeta);
    dN[19*3 + 2] = 0.25 * (1.0 - xi_val) * (1.0 - eta*eta);

}

// ============================================================================
// Gauss Quadrature
// ============================================================================

void Hex20Element::compute_gauss_points_27pt(Real* points, Real* weights) const {
    // 27-point Gauss quadrature (3x3x3) for quadratic elements
    // Gauss point locations: 0, ±√(3/5)
    const Real a = std::sqrt(0.6);  // √(3/5) ≈ 0.774596669
    const Real gp[3] = {-a, 0.0, a};
    const Real gw[3] = {5.0/9.0, 8.0/9.0, 5.0/9.0};

    int idx = 0;
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) {
            for (int k = 0; k < 3; ++k) {
                points[idx*3 + 0] = gp[i];
                points[idx*3 + 1] = gp[j];
                points[idx*3 + 2] = gp[k];
                weights[idx] = gw[i] * gw[j] * gw[k];
                idx++;
            }
        }
    }
}

void Hex20Element::gauss_quadrature(Real* points, Real* weights) const {
    // Use 3x3x3 Gauss quadrature for quadratic elements
    compute_gauss_points_27pt(points, weights);
}

// ============================================================================
// Jacobian Computation
// ============================================================================

KOKKOS_INLINE_FUNCTION
Real Hex20Element::jacobian(const Real xi[3], const Real* coords, Real* J) const {
    // Compute Jacobian matrix: J[i][j] = ∂x_i/∂ξ_j
    // J = [∂x/∂ξ  ∂x/∂η  ∂x/∂ζ]
    //     [∂y/∂ξ  ∂y/∂η  ∂y/∂ζ]
    //     [∂z/∂ξ  ∂z/∂η  ∂z/∂ζ]

    // Get shape function derivatives
    Real dN[NUM_NODES * NUM_DIMS];
    shape_derivatives(xi, dN);

    // Initialize Jacobian to zero
    for (int i = 0; i < 9; ++i) {
        J[i] = 0.0;
    }

    // J = Σ (∂N_i/∂ξ_j) * x_i
    for (int i = 0; i < NUM_NODES; ++i) {
        const Real x = coords[i*3 + 0];
        const Real y = coords[i*3 + 1];
        const Real z = coords[i*3 + 2];

        const Real dNdxi   = dN[i*3 + 0];
        const Real dNdeta  = dN[i*3 + 1];
        const Real dNdzeta = dN[i*3 + 2];

        // First column: ∂/∂ξ
        J[0] += dNdxi * x;  // ∂x/∂ξ
        J[3] += dNdxi * y;  // ∂y/∂ξ
        J[6] += dNdxi * z;  // ∂z/∂ξ

        // Second column: ∂/∂η
        J[1] += dNdeta * x;  // ∂x/∂η
        J[4] += dNdeta * y;  // ∂y/∂η
        J[7] += dNdeta * z;  // ∂z/∂η

        // Third column: ∂/∂ζ
        J[2] += dNdzeta * x;  // ∂x/∂ζ
        J[5] += dNdzeta * y;  // ∂y/∂ζ
        J[8] += dNdzeta * z;  // ∂z/∂ζ
    }

    // Compute determinant
    const Real det_J = J[0] * (J[4] * J[8] - J[5] * J[7])
                     - J[1] * (J[3] * J[8] - J[5] * J[6])
                     + J[2] * (J[3] * J[7] - J[4] * J[6]);

    return det_J;
}

void Hex20Element::inverse_jacobian(const Real* J, Real* J_inv, Real det_J) const {
    // Compute inverse Jacobian using cofactor method
    const Real inv_det = 1.0 / det_J;

    // Cofactor matrix (transposed = adjugate)
    J_inv[0] = inv_det * (J[4] * J[8] - J[5] * J[7]);
    J_inv[1] = inv_det * (J[2] * J[7] - J[1] * J[8]);
    J_inv[2] = inv_det * (J[1] * J[5] - J[2] * J[4]);

    J_inv[3] = inv_det * (J[5] * J[6] - J[3] * J[8]);
    J_inv[4] = inv_det * (J[0] * J[8] - J[2] * J[6]);
    J_inv[5] = inv_det * (J[2] * J[3] - J[0] * J[5]);

    J_inv[6] = inv_det * (J[3] * J[7] - J[4] * J[6]);
    J_inv[7] = inv_det * (J[1] * J[6] - J[0] * J[7]);
    J_inv[8] = inv_det * (J[0] * J[4] - J[1] * J[3]);
}

Real Hex20Element::shape_derivatives_global(const Real xi[3], const Real* coords, Real* dNdx) const {
    // Get shape function derivatives w.r.t. natural coordinates
    Real dN[NUM_NODES * NUM_DIMS];
    shape_derivatives(xi, dN);

    // Compute Jacobian
    Real J[9];
    const Real det_J = jacobian(xi, coords, J);

    // Compute inverse Jacobian
    Real J_inv[9];
    inverse_jacobian(J, J_inv, det_J);

    // Transform derivatives: dN/dx = J^{-1} * dN/dξ
    for (int i = 0; i < NUM_NODES; ++i) {
        const Real dNdxi   = dN[i*3 + 0];
        const Real dNdeta  = dN[i*3 + 1];
        const Real dNdzeta = dN[i*3 + 2];

        dNdx[i*3 + 0] = J_inv[0] * dNdxi + J_inv[1] * dNdeta + J_inv[2] * dNdzeta;
        dNdx[i*3 + 1] = J_inv[3] * dNdxi + J_inv[4] * dNdeta + J_inv[5] * dNdzeta;
        dNdx[i*3 + 2] = J_inv[6] * dNdxi + J_inv[7] * dNdeta + J_inv[8] * dNdzeta;
    }

    return det_J;
}

// ============================================================================
// B-Matrix (Strain-Displacement)
// ============================================================================

KOKKOS_INLINE_FUNCTION
void Hex20Element::strain_displacement_matrix(const Real xi[3], const Real* coords, Real* B) const {
    // B-matrix: 6 x 60 (6 strain components, 60 DOFs)

    // Initialize B to zero
    for (int i = 0; i < 6 * NUM_DOF; ++i) {
        B[i] = 0.0;
    }

    // Get shape function derivatives w.r.t. global coordinates
    Real dNdx[NUM_NODES * NUM_DIMS];
    shape_derivatives_global(xi, coords, dNdx);

    // Fill B-matrix for each node
    for (int i = 0; i < NUM_NODES; ++i) {
        const Real dNdx_i = dNdx[i*3 + 0];
        const Real dNdy_i = dNdx[i*3 + 1];
        const Real dNdz_i = dNdx[i*3 + 2];

        const int col = i * 3;

        // εxx row (row 0)
        B[0 * NUM_DOF + col + 0] = dNdx_i;

        // εyy row (row 1)
        B[1 * NUM_DOF + col + 1] = dNdy_i;

        // εzz row (row 2)
        B[2 * NUM_DOF + col + 2] = dNdz_i;

        // γxy row (row 3)
        B[3 * NUM_DOF + col + 0] = dNdy_i;
        B[3 * NUM_DOF + col + 1] = dNdx_i;

        // γyz row (row 4)
        B[4 * NUM_DOF + col + 1] = dNdz_i;
        B[4 * NUM_DOF + col + 2] = dNdy_i;

        // γxz row (row 5)
        B[5 * NUM_DOF + col + 0] = dNdz_i;
        B[5 * NUM_DOF + col + 2] = dNdx_i;
    }
}

// ============================================================================
// Constitutive Matrix
// ============================================================================

void Hex20Element::constitutive_matrix(Real E, Real nu, Real* C) const {
    // Elastic constitutive matrix (same as Hex8)
    for (int i = 0; i < 36; ++i) {
        C[i] = 0.0;
    }

    const Real lambda = E * nu / ((1.0 + nu) * (1.0 - 2.0 * nu));
    const Real mu = E / (2.0 * (1.0 + nu));

    const Real diag = lambda + 2.0 * mu;
    C[0*6 + 0] = diag;
    C[1*6 + 1] = diag;
    C[2*6 + 2] = diag;
    C[3*6 + 3] = mu;
    C[4*6 + 4] = mu;
    C[5*6 + 5] = mu;

    C[0*6 + 1] = lambda;
    C[0*6 + 2] = lambda;
    C[1*6 + 0] = lambda;
    C[1*6 + 2] = lambda;
    C[2*6 + 0] = lambda;
    C[2*6 + 1] = lambda;
}

// ============================================================================
// Mass Matrix
// ============================================================================

void Hex20Element::mass_matrix(const Real* coords, Real density, Real* M) const {
    // Consistent mass matrix: M = ∫ ρ N^T N dV
    // M: 60x60 matrix

    // Initialize to zero
    for (int i = 0; i < NUM_DOF * NUM_DOF; ++i) {
        M[i] = 0.0;
    }

    // Use 27-point Gauss quadrature
    Real gp[27*3], gw[27];
    compute_gauss_points_27pt(gp, gw);

    // Integrate over all Gauss points
    for (int ig = 0; ig < 27; ++ig) {
        Real xi[3] = {gp[ig*3 + 0], gp[ig*3 + 1], gp[ig*3 + 2]};
        const Real weight = gw[ig];

        // Compute shape functions
        Real N[NUM_NODES];
        shape_functions(xi, N);

        // Compute Jacobian determinant
        Real J[9];
        const Real det_J = jacobian(xi, coords, J);

        const Real factor = density * weight * det_J;

        // Assemble: M[i,j] += ρ * N_i * N_j * det(J) * w
        // Note: For 3D elements, each node has 3 DOFs (x, y, z)
        // The mass matrix has block-diagonal structure with M_ij on each diagonal
        for (int i = 0; i < NUM_NODES; ++i) {
            for (int j = 0; j < NUM_NODES; ++j) {
                const Real mass_ij = factor * N[i] * N[j];

                // Add to diagonal entries of the 3x3 block for node pair (i,j)
                for (int d = 0; d < NUM_DIMS; ++d) {
                    const int row = i * NUM_DIMS + d;
                    const int col = j * NUM_DIMS + d;
                    M[row * NUM_DOF + col] += mass_ij;
                }
            }
        }
    }
}

void Hex20Element::lumped_mass_hrz(const Real* coords, Real density, Real* M_lumped) const {
    // HRZ (Hinton-Rock-Zienkiewicz) lumping for quadratic serendipity elements
    // For Hex20, we use a special lumping scheme that evaluates mass contributions
    // at specific "lumping points" to ensure positive masses
    //
    // The key insight: for serendipity elements, integrating shape functions
    // over the element can give negative values for corner nodes. Instead, we
    // use a diagonal scaling approach where each node gets a fraction of the
    // total element mass proportional to its geometric position.
    //
    // For Hex20:
    // - Corner nodes (0-7): Each gets mass scaled by factor based on position
    // - Mid-edge nodes (8-19): Each gets mass scaled by their interpolation weight

    // First, compute total element mass via standard integration
    Real gp[27*3], gw[27];
    compute_gauss_points_27pt(gp, gw);

    Real total_mass = 0.0;
    for (int ig = 0; ig < 27; ++ig) {
        Real xi[3] = {gp[ig*3 + 0], gp[ig*3 + 1], gp[ig*3 + 2]};
        Real J[9];
        const Real det_J = jacobian(xi, coords, J);
        total_mass += density * gw[ig] * det_J;
    }

    // Distribute mass using HRZ weights for Hex20
    // Based on Hinton, Rock & Zienkiewicz (1976)
    // For Hex20 serendipity elements:
    // - Corner nodes (0-7): Each gets weight 1
    // - Mid-edge nodes (8-19): Each gets weight 4
    // Total weight: 8×1 + 12×4 = 8 + 48 = 56

    const Real corner_weight = 1.0;
    const Real midedge_weight = 4.0;
    const Real total_weight = 8.0 * corner_weight + 12.0 * midedge_weight;  // 56
    const Real mass_per_weight = total_mass / total_weight;

    // Assign masses according to node type
    for (int i = 0; i < 8; ++i) {
        // Corner nodes (0-7)
        M_lumped[i] = corner_weight * mass_per_weight;
    }
    for (int i = 8; i < 20; ++i) {
        // Mid-edge nodes (8-19)
        M_lumped[i] = midedge_weight * mass_per_weight;
    }
}

// ============================================================================
// Stiffness Matrix
// ============================================================================

void Hex20Element::stiffness_matrix(const Real* coords, Real E, Real nu, Real* K) const {
    // Element stiffness matrix: K = ∫ B^T C B dV
    // K: 60x60 matrix

    // Initialize to zero
    for (int i = 0; i < NUM_DOF * NUM_DOF; ++i) {
        K[i] = 0.0;
    }

    // Compute constitutive matrix
    Real C[36];
    constitutive_matrix(E, nu, C);

    // Use 27-point Gauss quadrature
    Real gp[27*3], gw[27];
    compute_gauss_points_27pt(gp, gw);

    // Temporary arrays
    Real B[6 * NUM_DOF];   // 6 x 60
    Real CB[6 * NUM_DOF];  // C * B

    // Integrate over all Gauss points
    for (int ig = 0; ig < 27; ++ig) {
        Real xi[3] = {gp[ig*3 + 0], gp[ig*3 + 1], gp[ig*3 + 2]};
        const Real weight = gw[ig];

        // Compute B-matrix
        strain_displacement_matrix(xi, coords, B);

        // Compute Jacobian determinant
        Real J[9];
        const Real det_J = jacobian(xi, coords, J);

        // CB = C * B (6x6 * 6x60 = 6x60)
        for (int i = 0; i < 6; ++i) {
            for (int j = 0; j < NUM_DOF; ++j) {
                CB[i * NUM_DOF + j] = 0.0;
                for (int k = 0; k < 6; ++k) {
                    CB[i * NUM_DOF + j] += C[i * 6 + k] * B[k * NUM_DOF + j];
                }
            }
        }

        const Real factor = weight * det_J;

        // K += B^T * CB * det(J) * w
        for (int i = 0; i < NUM_DOF; ++i) {
            for (int j = 0; j < NUM_DOF; ++j) {
                Real sum = 0.0;
                for (int k = 0; k < 6; ++k) {
                    sum += B[k * NUM_DOF + i] * CB[k * NUM_DOF + j];
                }
                K[i * NUM_DOF + j] += factor * sum;
            }
        }
    }
}

// ============================================================================
// Strain and Stress Computation
// ============================================================================

KOKKOS_INLINE_FUNCTION
void Hex20Element::compute_strain(const Real* coords, const Real* disp, Real* strain) const {
    // Compute strain from displacement: ε = B * u
    // Using element center

    Real xi[3] = {0.0, 0.0, 0.0};

    // Compute B-matrix at center
    Real B[6 * NUM_DOF];
    strain_displacement_matrix(xi, coords, B);

    // Initialize strain to zero
    for (int i = 0; i < 6; ++i) {
        strain[i] = 0.0;
    }

    // Compute strain: ε = B * u
    for (int i = 0; i < 6; ++i) {
        for (int j = 0; j < NUM_DOF; ++j) {
            strain[i] += B[i * NUM_DOF + j] * disp[j];
        }
    }
}

KOKKOS_INLINE_FUNCTION
void Hex20Element::compute_stress(const Real* strain, Real E, Real nu, Real* stress) const {
    // Compute stress from strain: σ = C * ε (same as Hex8)

    const Real lambda = E * nu / ((1.0 + nu) * (1.0 - 2.0 * nu));
    const Real mu = E / (2.0 * (1.0 + nu));

    stress[0] = (lambda + 2.0 * mu) * strain[0] + lambda * (strain[1] + strain[2]);
    stress[1] = (lambda + 2.0 * mu) * strain[1] + lambda * (strain[0] + strain[2]);
    stress[2] = (lambda + 2.0 * mu) * strain[2] + lambda * (strain[0] + strain[1]);

    stress[3] = mu * strain[3];
    stress[4] = mu * strain[4];
    stress[5] = mu * strain[5];
}

// ============================================================================
// Internal Force
// ============================================================================

KOKKOS_INLINE_FUNCTION
void Hex20Element::internal_force(const Real* coords, const Real* disp,
                                   const Real* stress, Real* fint) const {
    // Internal force: f_int = ∫ B^T σ dV
    // Note: This simple version uses element center only
    // For accuracy, should integrate over all Gauss points

    // Initialize to zero
    for (int i = 0; i < NUM_DOF; ++i) {
        fint[i] = 0.0;
    }

    Real xi[3] = {0.0, 0.0, 0.0};

    // Compute B-matrix at center
    Real B[6 * NUM_DOF];
    strain_displacement_matrix(xi, coords, B);

    // Compute Jacobian determinant
    Real J[9];
    const Real det_J = jacobian(xi, coords, J);

    const Real factor = det_J * 8.0;  // Weight for full domain

    // f_int = B^T * σ * det(J) * w
    for (int i = 0; i < NUM_DOF; ++i) {
        Real sum = 0.0;
        for (int j = 0; j < 6; ++j) {
            sum += B[j * NUM_DOF + i] * stress[j];
        }
        fint[i] = factor * sum;
    }
}

// ============================================================================
// Geometric Queries
// ============================================================================

bool Hex20Element::contains_point(const Real* coords, const Real* point, Real* xi) const {
    // Newton-Raphson iteration (same logic as Hex8, but with Hex20 shape functions)
    const int max_iter = 20;
    const Real tol = 1.0e-6;

    // Initial guess: element center
    xi[0] = 0.0;
    xi[1] = 0.0;
    xi[2] = 0.0;

    for (int iter = 0; iter < max_iter; ++iter) {
        // Compute current position
        Real N[NUM_NODES];
        shape_functions(xi, N);

        Real x_current[3] = {0.0, 0.0, 0.0};
        for (int i = 0; i < NUM_NODES; ++i) {
            x_current[0] += N[i] * coords[i*3 + 0];
            x_current[1] += N[i] * coords[i*3 + 1];
            x_current[2] += N[i] * coords[i*3 + 2];
        }

        // Residual
        Real r[3];
        r[0] = point[0] - x_current[0];
        r[1] = point[1] - x_current[1];
        r[2] = point[2] - x_current[2];

        const Real r_norm = std::sqrt(r[0]*r[0] + r[1]*r[1] + r[2]*r[2]);
        if (r_norm < tol) {
            return (std::abs(xi[0]) <= 1.0 + tol &&
                    std::abs(xi[1]) <= 1.0 + tol &&
                    std::abs(xi[2]) <= 1.0 + tol);
        }

        // Compute Jacobian
        Real J[9];
        jacobian(xi, coords, J);

        const Real det_J = J[0] * (J[4] * J[8] - J[5] * J[7])
                         - J[1] * (J[3] * J[8] - J[5] * J[6])
                         + J[2] * (J[3] * J[7] - J[4] * J[6]);

        if (std::abs(det_J) < 1.0e-12) {
            return false;
        }

        // Update using J^{-1} * r
        const Real inv_det = 1.0 / det_J;
        Real J_inv_r[3];
        J_inv_r[0] = inv_det * ((J[4]*J[8] - J[5]*J[7])*r[0] + (J[2]*J[7] - J[1]*J[8])*r[1] + (J[1]*J[5] - J[2]*J[4])*r[2]);
        J_inv_r[1] = inv_det * ((J[5]*J[6] - J[3]*J[8])*r[0] + (J[0]*J[8] - J[2]*J[6])*r[1] + (J[2]*J[3] - J[0]*J[5])*r[2]);
        J_inv_r[2] = inv_det * ((J[3]*J[7] - J[4]*J[6])*r[0] + (J[1]*J[6] - J[0]*J[7])*r[1] + (J[0]*J[4] - J[1]*J[3])*r[2]);

        xi[0] += J_inv_r[0];
        xi[1] += J_inv_r[1];
        xi[2] += J_inv_r[2];
    }

    return false;
}

Real Hex20Element::volume(const Real* coords) const {
    // Compute volume using 27-point Gauss quadrature
    Real gp[27*3], gw[27];
    compute_gauss_points_27pt(gp, gw);

    Real vol = 0.0;
    for (int ig = 0; ig < 27; ++ig) {
        Real xi[3] = {gp[ig*3 + 0], gp[ig*3 + 1], gp[ig*3 + 2]};
        const Real weight = gw[ig];

        Real J[9];
        const Real det_J = jacobian(xi, coords, J);

        vol += weight * det_J;
    }

    return vol;
}

Real Hex20Element::characteristic_length(const Real* coords) const {
    // Compute minimum edge length among corner nodes
    // We only check corner-to-corner edges (not mid-node edges)

    const int edges[12][2] = {
        {0, 1}, {1, 2}, {2, 3}, {3, 0},  // Bottom face
        {4, 5}, {5, 6}, {6, 7}, {7, 4},  // Top face
        {0, 4}, {1, 5}, {2, 6}, {3, 7}   // Vertical edges
    };

    Real min_length = 1.0e30;

    for (int ie = 0; ie < 12; ++ie) {
        const int n0 = edges[ie][0];
        const int n1 = edges[ie][1];

        const Real dx = coords[n1*3 + 0] - coords[n0*3 + 0];
        const Real dy = coords[n1*3 + 1] - coords[n0*3 + 1];
        const Real dz = coords[n1*3 + 2] - coords[n0*3 + 2];

        const Real length = std::sqrt(dx*dx + dy*dy + dz*dz);
        min_length = std::min(min_length, length);
    }

    return min_length;
}

} // namespace fem
} // namespace nxs
